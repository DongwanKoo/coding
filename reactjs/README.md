# How To Make App

## React.js, React-Native, Flutter, Android, iOS, Xamarin, Python and etc.

[![N|Solid](https://cldup.com/dTxpPi9lDf.thumb.png)](https://github.com/aidenkoog)

## React.js

- 페이지 상호작용
- 전통적인 웹 구현 방식 (HTML 요청 -> 서버로부터 HTML 수집)
- 리액트란 무엇인가?
- 왜 자바스크립트 대신 리액트를 사용하는가?
- 리액트 구동되는 메커니즘
- 리액트 선택 장점
  - 코드의 양
  - 명령형 프로그래밍 X
  - 복잡한 인터페이스 구현에 적합, 선언형 컴포넌트 (컴포넌트 기반)
  - 싱글 페이지 어플리케이션 (서버는 오직 하나의 HTML 만을 전달한다.)
  - 추가적인 기능이 필요한 경우 외부 라이브러리 설치 필요
- 프레임워크 / 라이브러리 차이점
  - 앵귤러 - 처음부터 타입스크립트 수용 / 컴포넌트 중심 / 기능 많음
  - 뷰 - 컴포넌트 기반, 기능은 리액트보다는 많음
  - 리액트, 앵귤러, 뷰 간의 차이 / 선택 기준은 무엇인가?
- props, state, 컴포넌트 스타일링, 리액트 훅, Refs, Context API, 리덕스
- 데이터베이스, HTTP, 라우팅, 배포 방법, 넥스트 JS
- 모던 자바스크립트
- 비주얼 스튜디오 코드
- let, const
- 화살표 함수 (키워드 this 이슈)
- Export / Import Modules (default, as, \*) / Named Import
- Class, Property, Method (클래스와 화살표 함수 간의 관계)
- 연산자
  - Spread 연산자 (배열의 원소를 펼칠 때, 클래스 안에서 … 사용법)
  - 레스트 연산자 (함수에서 사용, filter 연산)
- Destructuring
- 객체와 배열은 참조형 자료 타입, 재할당한다면 값이 아닌 포인터를 복사하는 것, 자체를 복사하고 싶으면 즉, 진짜로 복사하고 싶다면 프로퍼티를 복사해야 한다.
- 자바스크립트 ES6, 7 등 버전에 따른 차이점
- 배열함수 (map)
- 모질라 자바스크립트 네트워크에서 추가 설명
- JSX, Component Usage, Data Handling
- 리액트는 컴포넌트에 대한 모든 것 (리액트 = 컴포넌트)
- 왜 컴포넌트인가 ? : 재사용성, 관심사 분리 OOP 적 완성을 위한 목적
- 커스텀 HTML Element 구성 => 리액트
- 앱 설치 및 실행에 필요한 요소들
  - Node.js (자바 스크립트 런타임)
  - npm, yarn install
- index.js, index.html (div id="root")
- JSX: 작성 용이, 브라우저에서 해석 가능, 화면 뒷단에서 변경 (개발자 도구 (크롬))
- 기본적으로 커스텀 HTML 요소
- 관례: 첫단어 대문자, 카멜 케이스 적용
- 가독성을 위해 괄호로 태그를 묶는다. (return (div…div))
- text 태그없이 div 내에 텍스트 작성 가능 (경고 메세지 제거 위한 목적)
- 다른 컨텐츠 주변에서 셀 역할을 하는 컴포넌트를 생성하고 싶다면 ?
  - 각각의 컨텐츠들에서 공통적인 속성을 묶을 때 컴포지션 children prop 사용
  - 재사용 가능한 래퍼 컴포넌트를 만들기 위한 목적
  - 클래스네임 중첩
  - 컴포넌트를 결합할 때 마다 컴포지션 개념을 사용
- 내부적으로 JSX 문법은 아래와 같이 변환된다.
  - React.createElement() <-- 세가지 인자 필요 (태그 이름, 속성 객체, 컨텐츠 컴포넌트 정보)
  - React.createElement('div', {}, React.createElement('h2', {}, "TEST"), React.createElement(Object, {items: objItems})
- function 스타일 --> 대체 함수 문법 (화살표 함수)
- 관례적인 함수 작명법
- useState
  - 사전 지식
    - 컴포넌트는 JSX 를 반환하는 함수형이므로 누군가는 호출을 해줘야 한다.
    - JSX 는 함수 불러오기의 나열 / 모든 것은 index.js 에서 부터 시작
    - 기본적으로 리액트는 화면 렌더링을 반복하지 않는다.
    - 그러므로 리액트에게 어떤 것이 변경되었고 특정 컴포넌트가 업데이트 되어야 한다고 알려줘야 함.
  - 컴포넌트 함수 바깥 및 중첩된 함수 내에서는 동작하지 않음
  - 배열을 반환
  - 컴포넌트 함수는 useState 를 업데이트하는 함수, useState를 초기화했던 부분에서 다시 시작된다. (set을 할 경우)
  - setXXX 는 리액트에게 상태를 변경하고 싶다고 알리고 useState 에게 state가 등록된 컴포넌트가 업데이트 되어야 한다고 리액트에게 알린다.
  - setXXX 는 바로 값을 변경하지 않고 대신 이 state의 업데이트를 예약한다. (그래서 다음 라인에서 로그 출력 시도를 해도 값이 그대로임)
  - State 는 컴포넌트 인스턴트 별로 나뉘어져 있음.
  - 가장 최근에 설정된 값을 항상 보여준다.
  - 여러가지 상태를 업데이트하는 경우 객체로서 업데이트도 가능
  - 이전 상태에 의존하는 상태 업데이트 (ex. setUserInput((prevState) => { return { ...prevState, enteredName: event.name}) <-- 스냅샷 이용 방법 권장
- 입력창 처리 : form 태그 (label, input 태그)
  - onChange (event 객체, event.target.value)
  - form 태그 onSubmit (button type 이 'submit')
  - 기본적으로 서브밋을 하면 웹페이지가 갱신된다. (event.preventDefault())
  - input 태그의 value 속성
- 부모 <-> 자식 컴포넌트 간 통신 방법
- Lifting State Up (자식 --> 부모 --> 다른 자식)
- select 태그 (option 태그)
- 컴포넌트 용어 (참고)
  - 프레젠테이셔널 / 덤프 컴포넌트 / 무상태 컴포넌트
  - 스마트 / 상태 유지 컴포넌트
- {} 와 배열 map() 활용한 동적 리스트 구성
- 아이템 keys 이해 --> 리액트가 모든 아이템을 정확하게 인식할 수 있게 하기 위한 목적
- 배열 filter 연산 (props.items.filter(item => { return item.date.getFullYear().toString() === filteredYear})
- JSX 구문 복잡성을 줄이고 컴포넌트 함수 상단에서 연산을 처리하는 방향으로 코딩
- 조건부 내용 출력 건 => && 연산 뒤의 내용이 출력되므로 이를 활용 가능
- JSX 코드를 변수에 저장하는 것 가능
- ul, li 태그
- 동적 스타일 추가
  - 동적 스타일 추가 (style): style={{}}
  - 동적 스타일 추가 백틱 문자열 기호 사용한 클래스 네임
  - 패키지: styled components
